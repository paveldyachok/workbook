# Основы ООП

## Классы и объекты <a id="classes"></a>

Переменные объявленные в классе называются - **свойства**.

Поведение объектов описывается **методами**, это функции которые указываются внутри класса.

**$this** - это текущий объект. Тоесть ссылка на тот объект, который и вызывает обращением данного свойства или метода. Обращение в классах к свойствам и методам происходить **только через $this** !

```php
class Pet // Класс с именем Pet
{
    public $name; // Свойство $name с модификатором public
    public $age = 0;
    function say($w) // Метод класса
    {
        // Доступ к свойству
        echo "{$this->name} said {$w}";
        // Доступ к методу
        $this->drawLine();
    }
    function drawLine()
    {
    echo "<hr>";
    }
}

$cat = new Pet(); // Объект (экземпляр) класса Pet записанный в переменную $cat

echo $cat->age; // С помощью стрелки "->" обращаемся к свойству объекта

$cat->name = "Мурзик"; // Таким же образом можно записывать данные в свойство объекта

$cat->say("Miay"); // Обращение к методу объекта
```

## Использование псевдоконстант

`__FUNCTION__` - передаёт имя функции

`__CLASS__` - передаёт имя класса

`__METHOD__` - передаёт имя метода в формате "ИмяКласса::имяМетода"

## Конструкторы и деструкторы <a id="construct"></a>

**Конструктор** - это специальный метод, который вызывается автоматически. Вызывается конструктор специальным служебным методом: `__construct()`. В круглых скобках при создании объекта \(экземпляра\) класса можно передавать параметры в конструктор.

**Деструктор** - специальный метод `__destruct()` вызывается автоматически при освобождении всех ссылок на определенный объект или при завершении скрипта \(порядок выполнения деструкторов не гарантируется\). В деструктор нет возможности передать параметры. Порядок удаления объктов неопределён, по этому **нельзя** напрямую обращаться к другому объекту из деструктора.

```php
class Pet
{
    // Описание свойств
    public $type = "unknown";
    public $name;
    // Конструктор класса
    public function __construct($type, $name)
    {
        $this->type = $type;
        $this->name = $name;
        echo "My {$this->type} name {$this->name}\n";
    }
    // Деструктор класса
    public function __destruct()
    {
        echo $this->name . " removed\n";
    }
}

// Создание объектов, экземпляров класса
$cat = new Pet("cat", "Murzik");
$dog = new Pet("dog", "Tuzik");
```

## Клонирование объектов <a id="clone"></a>

```php
$objY = $objX; // $objY - ссылка на $objX
// Тоже самое что в процедурном стиле
$objY = &$objX;
```

Если мы хоти получить другой объект как копию, используем `clone`:

```php
$objZ = clone $objX; // $objZ копия $objX
```

Но при клонирование конструктор не буде запускаться. Если необходимо выполнить автозапуск после клонирования, объявляем метод `__clone()` в классе:

```php
function __clone()
{
    echo "Object cloned";
}
```

Передать параметры в данном случае **нельзя**.

## Наследование классов <a id="inheritance"></a>

```php
// Создание класса-наследника
class FabricHouse extends SimpleHouse{}
```

С помощью слова `extends` _\(расширять\)_, при создание нового класса, мы указываем необходимость переслать все свойства и методы из класса `SimpleHouse` в новосозданный `FabricHouse`.

PHP **не** поддерживает множественное наследование, но можно создавать цепочки наследования.

Для **переопределения методов** родительского класса, в новом классе прописываем метод с аналогичным названием. Если необходимо вызвать основной \(родительский\) метод, используем `parent::имяМетода();`.

## Обработка исключений <a id="exception"></a>

```php
function test($var = false)
{
    try {
        echo "Start\n";
        if (!$var) {
            throw new Exception('$var is false!');
        }
        echo "Continue\n";
    } catch (Exception $e) {
        echo "Exception: " . $e->getMessage() . "\n"; // getMessage() выдаст то, что передалось в конструктор Exception
        echo "in file: " . $e->getFile() . "\n"; // Файл в котором это произошло
        echo "on line: " . $e->getLine() . "\n"; // Номер строки throw new Exception('$var is false!');
    }
    echo "The end\n";
}
```

При возникновении `Exception` \(исключения\), создастся экземпляр встроенного класса: `new Exception('$var is false!');`, и с помощью `throw` \(бросить\) этот объект будет ссылаться на переменную `$e` в `catch (Exception $e)`. В таком случае строка `echo "Continue\n";` не выполнится. Если `$var = true`, то блок `catch` запускаться не будет.

`Exception` в `catch (Exception $e)` указывает, ссылка на объект какого класса должна быть в переменной. Таким образом можно создавать несколько `catch`-ей, и в каждом указывать свой обработчик. При этом самый основной \(родительский\) класс должен быть в самом низу, тоесть распологать в обратном порядке!

## Абтрактные классы и методы <a id="abstractAndInterface"></a>

Для создания абстрактного класса указываем `abstract` перед `class`.

Мы не можем создать экземпляр абстракного класса, так как они созданы как "набросок" и используются только для наследования. Так же в таком классе могут быть **абстрактные методы** - это метод без реализации. А реализация данного метода **обязательно** происходит в дочерних классах.

## Интерфейсы

Это абстрактные классы, которые содержат **только** абстрактные методы.

Интерфейс назначается словом `interface` и перед методами не нужно писать слово _abstract_.

```php
interface Paintable
{
    // Абстрактный метод
    function paint();
}
```

Интерфейсы не наследуются а реализуются с помощью слова `implements` \(принадлежности\). Можно подключить один и более интерфейсов в один класс. Очень часто интерфейсы используются как признаки.

```php
// Проверка класса в цепочке предков
if($simple instanceOf Paintable){
    $simple->paint();
}
$simple->stopProject();
```

`instanceOf` - провеяет, есть ли у всей цепочки объекта указаного слева, интерфейс указанный справа.

## Константы и статические члены класса <a id="const"></a>

В классах можно объявлять **константы**, но к ним нельзя обратиться через объект, так как они относятся только к классу. Для обращения к константам из экземпляра класса, испльзуем `self::NAME`, для обращения из вне класса: `ИмяКласса::ИМЯ_КОНСТАНТЫ`.

```php
class СonstructionCompany
{
    const NAME = "Рога и копыта";
    function printName()
    {
        // Обращение к константе из метода класса
        echo self::NAME;
    }
}
```

Так же в классах можно объявлять статические свойства и методы с помощью слова `static`. Обращение к ним такое же как и к константам, только при обращении к свойствам обязательно нужно указать $, `self::$workerCount`. Внутри статических методов не может быть `$this`, только `self::`.

```php
public static $workerCount = 0;
static function welcome(){}
```

* `parent::` - вызываем родительский метод \(не обязательно статичный\).
* `self::` - вызываем метод именно этого класса.
* `static::` - вызываем метод текущего класса.

## Автоматическая загрузка класса <a id="autoload"></a>

Если мы попробуем создать объект без заранее прописанного класса, то мы получим ошибку, что класс не найден.

```php
$myClass = new MyClass();
```

Но если мы объявим функцию `function __autoload($class)`, то перед выбрасыванием ошибки скрипт выполнит данную функцию и параметром примет название класса экземпляр которого мы пытаемся создать.

Таким образом в данной функции можно автоматически подключать файлы с небходимыми классами:

```php
function __autoload($class)
{
    include "{$class}.class.php";
}
```

Более качественная реализация:

```php
function my_autoloader($class)
{
    include 'classes/' . $class . '.class.php';
}

spl_autoload_register('my_autoloader');
```

## Модификаторы доступа к свойствам и методам <a id="modifiers"></a>

Существуют **три** модификатора доступа:

* `public` - полный доступ отовсюда.
* `protected` - запрещает обращение из вне класса. Только из самого класса или наследника.
* `private` - разрешает доступ только из класса в котором объявлен.

## Доступ к недоступным свойствам и методам

С помощью встроенных методов `__set()` и `__get()` мы можем получать доступ к недоступным свойствам. А спомощью метода `__call()` - к недоступным методам. Для доступа к статическому методу - `__callStatic()`.

```php
class SimpleHouse
{
    private $color = "none";

    function __get($name)
    {
        switch ($name) {
            case 'color': return $this->color;
            default: throw new Exception('Неизвестное свойство!');
        }
    }

    function __set($name, $value)
    {
        switch ($name) {
            case 'color': $this->color = $value; break;
            default: throw new Exception('Неизвестное свойство!');
        }
    }

    function __call($n, $args)
    {
        echo "Call method $n with args";
        print_r($args);
    }

    function __callStatic($n, $args)
    {
        echo "Call static method $n with args";
        print_r($args);
    }
}

$simple = new SimpleHouse("A-100-123", 120, 2);
$simple->color = "white"; // Запускается __set() и устанавливает значение свойства $color = "white";
echo $simple->color; // Заускается __get() и выдаёт значение свойства $color
$simple->color("red"); // Запускается __call() и вызывается метод color c аргументом "red"
$simple->staticFoo(1, 2, 3); // Запускается __call() и вызывается статический метод staticFoo c аргументами 1, 2, 3
```

## Финальные классы и методы <a id="final"></a>

Финальные классы или методы определяються словом `final` переда `class` или `function`. Такие классы нельзя наследовать, но можно создавать экземпляры - противоположность абстрактным классам.

Такие классы или методы создают тогда, когда ещё не полностью реализован весь функционал класса или метода.

## Типажи \(traits\)

Выглядят как классы, только вместо `class` используем `trait`.

```php
trait Hello
{
    function getGreet()
    {
        return "Hello";
    }
}

trait User
{
    function getUser($name)
    {
        return ucfirst($name);
    }
}

class Welcome
{
    use Hello, User;
}

$obj = new Welcome();
echo $obj->getGreet(), ', ', $obj->getUser('john'), '!'; // Hello, John!
```

## Полезные функции

[http://php.net/manual/ru/ref.classobj.php](http://php.net/manual/ru/ref.classobj.php)

