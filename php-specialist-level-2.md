# День - 1

## Изучение Cookie {#cookie}

Для сохранения cookie используем функцию `setcookie();`. Которая принимает семь параметров, из которых один обязательный.

#### Cookie имеет время жизни

- Временная - та которая хранится до закрытия браузера (вкладки).

- Долговременная - та, которой передан третий параметр, время хранения. Например: `time()+3600` - на один час.

#### Удаление Cookie

Отправляем запрос с "отрицательным" значением времени:

```php
setcookie("name", "John", time()-3600);
```

#### Массивы и Cookie

Так как все передаваемые запросы на сервер это строка, для пеедачи массива данных, нам необходимо произвести сериализацию (перевод массива в зашифрованную строку) и упаковать для сохранения целосности.

```php
$user = [
    'name' => 'John',
    'login' => 'root',
    'password' => '1234'
];
$str = base64_encode(serialize($user));
setcookie("user", $str);

// Получение куки
$user = unserialize(base64_decode($_COOKIE["user"]));
```

## HTTP-заголовки ответа сервера {#http-headers}

#### Переадресация ресурса

```php
// Переадресация со статусом 302
header("Location: http://mysite.local");
```

Для избегания повторной отправки данных формы методом POST, после обработки формы производим перезапрос методом GET.

_Пример:_

```php
if($_SERVER["REQUEST_METHOD"] == "POST") {
    // Форма передавала информацию
    $name = strip_tags($_POST["name"]);
    $age = $_POST["age"] * 1;

    // Сохранение в cookie
    setcookie("userName", $name);
    setcookie("userAge", $age);

    // Обработка формы
    // ...

    // Перезапрос формы методом GET
    header("Location: " . $_SERVER["PHP_SELF"]);
    exit;
}
```

Используем языковую конструкцию `exit;` для остановки выполнения скрипта. Так как страница будет переадресована и выполнение кода ниже данной переадресации не имеет смысла. Без данной конструкции ресурс будет тратиться впустую.

#### Перезапрос ресурса

```php
header("Refresh: 3");
header("Refresh: 3; url=http://mysite.local");
```

В данном случае `3` является время через которое должен произойти перезапрос (перезагрузка страницы). Вторым параметром можно указать адрес переадресации.

#### Установка типов содержимого

```php
// Принудительная установка типа передаваемого ресурса
header("Content-Type: text/xml");
// Принудительная установка кодировки передаваемого ресурса
header("Content-Type: text/html; charset=utf-8");
// Перенаправление вывода передаваемых данных
header("Content-Type: text/plain");
header("Content-Disposition: attachment filename=\"myfile.txt\"");
```

#### Управление кешированием

```php
// Запрет кэширования
header("Cache-Control: no-cache, max-age=0");
// Полный запрет кэширования
header("Cache-Control: no-store");
// Разрешение кэширования на один час относительно времени запроса
header("Cache-Control: max-age=3600");
// Разрешение кэширования на один час
header("Expires: " . date("r", time() + 3600);
```

`no-cache` - не запрещает временное кеширование.

#### Буферизация вывода

Буфер - пямять между сервером и php-скриптом. В буфер можно сохранять всё кроме заголовка.

```php
// Включаем буферизацию
ob_start();
echo 'Hello world!';
setcookie("name", "John");
// Посылаем содержимое буфера
ob_flush(); // Очищает буфер, но оставляет его открытым

echo 'Ещё контент!';
echo 'И ещё контент!'; // Эти данные попадут в буфер
// Посылаем содержимое буфера и отключаем его
ob_end_flush(); // Очищает буфер и закрываем его
```

Можно использовать буфер как глобальную переменную.

_Пример:_

```php
// Включаем буферизацию
ob_start();
echo "Hello ";
// Выбираем то, что находится в буфере. Его содержимое очищается!
$out1 = ob_get_contents();
echo "World";
// Выбираем то, что находится в буфере. Его содержимое очищается!
$out2 = ob_get_contents();
// А теперь очищаем буфер, но не закрываем
ob_clean();
echo "Саша";
echo " и ";
echo "Маша";
// Выбираем то, что находится в буфере
$out3 = ob_get_contents();
// Очищаем буфер и закрываем его
ob_end_clean();
echo $out1; // Hello
echo $out2; // Hello World
echo $out3; // Саша и Маша
```

## Использование сеансов (сессий) {#sessions}

Сессии нужны для сохранения переменных которые можно использовать в разных скриптах. В отличии от cookie, сессии хранятся на сервере, то есть пользователь не может свободно модифицировать (удалить) эти данные.
Фактически сессия, это текстовый файл на сервере, который создаётся при создании сессии. Каждый такой файл имеет название формата `sess_542834g32434gkl...` где после `sess_` уникальный идентификатор. Для идентификации клиента, ему посылается cookie с ID - php_sess_id и параметром "уникальный идентификатор".
По умолчанию время сессии до закрытия браузера.

#### Управление сеансами

```php
// Создание и(или) доступ к сессии
session_start();
// Запись в сессионную переменную
$_SESSION['name'] = 'John';
// Чтение из сессионной переменной
echo $_SESSION['name'];
// Очистка сессионных переменных
session_destroy();
// Принудительное удаление сессионной cookie
setcookie(session_name(), session_id(), time()-3600);
```

## Операции с файлами и директориями {#files-and-dirs}

#### Функция открытия потока файла

```php
// Открытие потока на чтение и получение его дескриптора
$f = fopen("file.txt", "r") or die("Не могу открыть файл!");
```

В переменную `$f` прийдёт дискриптор потока (идендификатор).

Режимы:

- r - открывает на чтение, указатель помещается в начало файла;
- r+ - чтение и запись, указатель помещается в начало файла;
- a - запись, указатель помещается в конец файла;
- a+ - чтение и запись, указатель помещается в конец файла;
- w - запись, файл обрезается до нулевой длины;
- w+ - чтение и запись, файл обрезается до нулевой длины;

##### Элеменарный парсинг

```php
// Читаем файл построчно в массив и вырезаем html-тэги, оставляя нужные
$f = fopen("file.html", "r");
$lines = [];
$lines[] = $line;
while ($line = fgetss($f, 4096, "<p><br>")) { // <p><br> - эти тэги останутся
    $lines[] = $line;
}
fclose($f);
```

#### Прямая работа с файлами

```php
// Читаем весь файл напрямую в буфер вывода
readfile("file.txt");
// Что и
$f = fopen("file.txt", "r");
echo fread($f, filesize("file.txt"));
fclose($f);

// Читаем файл построчно в массив
$lines = file("file.txt");
// Что и
$f = fopen("file.txt", "r");
while ($lines[] = fgets($f));
fclose($f);

// Получаем весь файл в виде строки
$file = file_get_contents("file.txt");
// Что и
$f = fopen("file.txt", "r");
$file = fread($f, filesize("file.txt"));
fclose($f);

// Пишем в файл добавляя содержимое в конец
file_put_contents("file.txt", "Новое содержимое", FILE_APPEND);
// Что и
$f = fopen("file.txt", "a");
fputs($f, "Новое содержимое");
fclose($f);
```

#### Работа с директориями

``` php
// Читаем содержимое директории в массив
$dir_content = scandir(".");
// Читаем определённое содержимое директории в массив
$dir_txt_content = glob("*.txt");
```

#### Загрузка файлов на сервер

Конфигурационные настройки php.ini

- `file_uploads = "1"` - разрешена ли загрузка файлов;
- `upload_max_filesize = "2M"` - максимальный размер загружаемого файла;
- `post_max_size = "8M"` - размер общих данных передаваемых через POST, учитывается не только размер самих файлов но и сопутствующие данные из формы;
- `max_file_uploads = 20` - количество одновременно загружаемых файлов;
- `upload_tmp_dir =` - можно задать название временной папки на сервере;
- `max_input_time = "-1"` - сколько времени мы даём на закачку файла, по умолчанию без ограничений;

`$_FILES["userfile"]["type"]` - информация о типе файла получается от расширения файла. Можно отправить исполняемый файл под видом допустим текстового.

`move_uploaded_file();` отличается от `copy();` тем, что проверяет был ли файл загружен по протоколу HTTP.

## Основы работы с СУБД {#DBMS}

Большие проекты начинаются с создания архитектуры БД!

#### SQL

SQL (англ. Structured Query Language — язык
структурированных запросов). Универсальный язык, применяемый для создания, модификации и управления данными в реляционных базах данных.

##### Удаление записи

``` sql
DELETE FROM lessons
    WHERE date = '2014-06-11'
```

**!!!** Если не указать `WHERE` - удалятся все данные из выбранной таблицы. Вернуть эти данные без бекапа невозможно!

##### Изменение записи

``` sql
UPDATE teachers
 SET
    zarplata = zarplata * 2,
    premia = premia * 10
 WHERE name LIKE 'Иванов%'
    OR name LIKE 'Петров%'
    OR name LIKE 'Сидоров%'

UPDATE teachers
 SET
    zarplata = zarplata * 2,
    premia = premia * 10
 WHERE name IN
    ('Иванов', 'Петров', 'Сидоров')
```

**!!!** Если не указать `WHERE` - удалятся все данные из выбранной таблицы.

#### Сервер баз данных MySQL

MySQL – один из самых распространенных **серверов** баз данных.

Конфигурационный файл my.ini:

- port = 3306
- datadir = "c:\\users\\public\\openserver\\userdata\\MySQL-5.5"
- default-storage-engine = InnoDB
- init-connect = "SET NAMES utf8"
- interactive_timeout = 30
- wait_timeout = 60
- connect_timeout = 5

#### Использование сервера баз данных MySQL в приложениях PHP

Алгоритм работы с СУБД MySQL:

- Подключение необходимого расширения в PHP.INI
- php_mysqli.dll
- Установка соединения с сервером
- Выбор базы данных для работы (при необходимости)
- Исполнение запроса
- Обработка данных (при необходимости)
- Закрытие соединения

##### Соединение с сервером баз данных

``` php
// Соединение и выбор базы данных
$link = mysqli_connect('localhost', 'root', '', 'web');
// Отслеживаем ошибки при соединении
if(!$link) {
    echo 'Ошибка: '
            . mysqli_connect_errno()
            . ':'
            . mysqli_connect_error();
}
// Можно выбрать другую базу данных для работы
mysqli_select_db($link, 'test');
// Закрываем соединение
mysqli_close($link);
```

Для распаковки получаемых данных из БД используем функцию `mysqli_fetch_array();`. По умолчанию получаем дублированный массив (индексированные и ассоциативные данные). Если нужен один из двух вариантов, используем такие запросы:

``` php
// Индексированный массив
$row = mysqli_fetch_row($result);
// или
$row = mysqli_fetch_array($result, MYSQLI_NUM);

// Ассоциативный массив
$row = mysqli_fetch_assoc($result);
// или
$row = mysqli_fetch_array($result, MYSQLI_ASSOC);
```

``` php
// Полная выборка: массив массивов
$row = mysqli_fetch_all($result, MYSQLI_ASSOC);
```

##### Полезные функции

``` php
$link = mysqli_connect('localhost', 'root', '', 'web');

// Экранируем строки!
$name = mysqli_real_escape_string($link, "John O'Brian");
$sql = "INSERT INTO teachers(name, email) VALUES('$name', 'johnh@gmail.com')";
mysqli_query($link, $sql);

// Получаем первичный ключ новой записи
$id = mysqli_insert_id($link);
$sql = "DELETE FROM lessons WHERE room = 'БК-1'";
mysqli_query($link, $sql);

// Сколько записей изменено?
$count = mysqli_affected_rows($link);
$sql = "SELECT * FROM courses";
$result = mysqli_query($link, $sql);

// Сколько записей вернулось?
$row_count = mysqli_num_rows($result);

// Сколько полей в вернувшихся записях?
$fields_count = mysqli_num_fields($result);
```

#### Опасность SQL-инъекций

При явном получении числа необходимо принудительно приводить получаемые данные к числу, и только после этого передавать приведённую переменную в SQL запрос.

При получении смешанных данных, можно использовать подготовленные запросы:

``` php
$sql = "INSERT INTO users(name, email, age) VALUES(?, ?, ?)";
// Уважаемый сервер, вот запрос - разбери его
$stmt = mysqli_prepare($link, $sql);
// Уважаемый сервер, вот параметры для запроса
mysqli_stmt_bind_param($stmt, "ssi", $name, $email, $age);
// А теперь, исполни подготовленный запрос с переданными параметрами
mysqli_stmt_execute($stmt);
mysqli_stmt_close($stmt);
```